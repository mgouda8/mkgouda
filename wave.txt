#!/usr/bin/ksh
#-------------------------------------------------------------------------------------------------
# Copyright (C) 2001-2016 Landis+Gyr.  All rights reserved.
#-------------------------------------------------------------------------------------------------

# ------------------------------------------------------------------------------------------------
# -- NAME:      wave.ksh
# -- PURPOSE:
#
# -- Version    JIRA        Date     Author     Type  Comments
# -- ---------  ----------  -------  ---------  ----- -------------------------------------------------------
# -- 1.0        MDMS-2026   03/12/08 Gary Lutz        Call getCUMGatewaysToProcess
# -- 1.1        MDMS-2154   03/23/08 JKorupalli       add -t option to enable sql trace.
# -- 1.2        MDMS-3398   11/11/08 Gary Lutz        Add function refreshRateStructureMV
# --                                                    Remove the -x processing option
# --                                                    Execute pkg_est.wave_main procedure
# -- 1.3 	MDMS-8020   07/13/10 REega     	      Support for device group management 
# -- 1.4        MDMS-10342  03/28/11 REega            Clone:MDMS-10200,Perform Exception staging from WAVE.
# -- 3.0.0.00   MDMS-9994   05/10/11 DEisert    E     Updated the following references
# --                                                     * removed Check_Env_Var ORAPASS references
# --                                                     * removed Check_Env_Var ORAUSER references
# --                                                     * removed TWO_TASK reference
# --                                                     * replaced mdmstab with mdmstab
# --                                                     * replaced mdmsenv with mdmsenv
# --                                                     * replaced MDMSENV_DIR with MDMSENV_DIR
# --                                                     * replaced connect string
# -- AUGUSTA    MDMS-10087  07/08/11 JZ         E     Create an oracle database user that can be used to connect through the Batch jobs, application server(s), install/upgrade scripts etc (instead of using the MDMS Schema Owner)
# -- 3.0.0.00   MDMS-11540  11/10/11 JZ		B     Move 'whenever oserror/sqlerror exit failure rollback' before connection string to catch connection failure
# -- KING	MDMS-19013  03/10/14 SE		E     Shell script changes to support 128 partitions/threads	
# -- LIGHTENING	MDMS-20786  05/20/14 PL		E	  Execute getNumberOfPartition to Retrieve the number of partitions from database
# -- 3.6.0.01   MDMS-25905  12/24/15 PL     	B     Made changes to ensure initializeScript executes at the start of script (Clone 3.8 MDMS-26376)
#
# ------------------------------------------------------------------------------------------------

function initializeScript {
export MDMSENV_DIR=/usr/local/bin

if [ ! -x ${MDMSENV_DIR}/mdmsenv ]; then
   print ${PGM_NM} Error - could not locate executable ${MDMSENV_DIR}/mdmsenv.
   exit 1
fi

unset inumProcesses
unset WACS_SID
unset inEntryDate
unset groupName
unset gatewayId

#numProcesses=8
#maxProcesses=64
#maxProcesses=128

sqlTrace=FALSE

while getopts hd:p:tw:g:n: CMD
do
   case $CMD in
        d) export inEntryDate=$OPTARG;;
        h) usage
           exit ${SUCCESS};;
        p) export inumProcesses=$OPTARG;;
	t) export sqlTrace=TRUE;;
        w) export WACS_SID=$OPTARG;;
        g) export gatewayId=$OPTARG;;
        n) export groupName=$OPTARG;;
        *) usage
           exit ${SUCCESS};;
   esac
done

. ${MDMSENV_DIR}/mdmsenv
if [ $? -ne 0 ]; then
   print ${PGM_NM} Error encountered while invoking ${MDMSENV_DIR}/mdmsenv.
   exit 1
fi
}

usage()
{
clear
print "wave.ksh"
print
print "WACS WAVE process"
print
print "Execute the WACS WAVE process.  By default, the current system date will be used"
print "for processing.  You may override this date by specifying the processing date by"
print "using the -d option described below."
print
print "Options:"
print
print "   -d DD-MON-YY      The overriding processing date where DD=day, MON=month, YY=year"
print "   -h                Help (this screen)."
print "   -p num            Number of parallel processing threads invoked (default = 8)"
print "   -g gateway_id     Gateway identifier (mr_gateway_id)"
print "   -n Group_name     Device group Name" 
print "   -w WACS_SID       WACS environment system identifier (see mdmstab)"
print "   -t                Enable SQL trace (default is not enabled)"
print
return 0
}

function processInputParameters {
if [ -n "${inEntryDate}" ]; then
   print
   print WARNING, PROCESSING DATE IS BEING OVERRIDDEN WITH ${inEntryDate} !
fi

if [ ${numProcesses} -gt ${maxProcesses} ]; then
   print Error - the maximum number of processing threads allowed is ${maxProcesses}
   Fail
fi

print
print Number of parallel processing threads:  ${numProcesses}

if [ "${sqlTrace}" = "TRUE" ]; then
   print
   print "SQL Trace has been enabled with the -t option"
   print
fi

if [ -n "${gatewayId}" ]; then
   print
   print "Gateway ID: ${gatewayId}"
   validateCUMGatewayId ${gatewayId} "${PGM_NM}" "WAVE" 
   rc=$?
   if [ ${rc} -eq 0 ]; then
   	print "Gateway ID: ${gatewayId} (validated).. "
   else
	print "Invalid gateway id ${gatewayId} .."
	Fail 
   fi
else
  print
  print "Gateway ID not passed so all the configured and active gateways will be processed!"  	
fi

if [ -n "${groupName}" ]; then
   print
   print "Group name : ${groupName}"
   if [ -n "${gatewayId}" ]; then
        # Gateway ID and Group name both passed. So we can validate Gateway/group combniation.
   	validateGatewayGroupName ${gatewayId} "${groupName}"  "WAVE"
	rc=$?
	if [ ${rc} -eq 0 ]; then
		print "Gatway ${gatewayId} / Group Name ${groupName}  combination  validated.."
		print
   	else
		print "Invalid gatway ${gatewayId} / Group Name ${groupName}  combination.."
		Fail 
	fi
   else
   	# Group name ONLY passed. So we can validate atleast Group before doing further work.
   	validateGroupName "${groupName}"  "WAVE"
	rc=$? 
	if [ ${rc} -eq 0 ]; then
                print "Group Name ${groupName} validated.."
                print
        else
                print "Invalid  Group Name ${groupName}"
		Fail
        fi
   fi
else
   print
   print "Group name not passed so all the configured and active groups for the gateways selected!"  	
   print
fi

#package call requires group ID .Find group ID since group name is already validated (and has unique index on group name).
if [ -n "${groupName}" ]; then
   getGroupIdFromName "${groupName}"
   rc=$?
   if [ ${rc} -ne 0 ]; then
     print Error getting the group ID from group name.
     Fail
   fi
   #groupId is exported in wacsib.
   print group ID: ${groupId}
else
   #Package requires to pass NULL if group name not passed to WAVE.
   groupId=NULL
fi
}

function invokeExceptionProcessing {
print
print Beginning Exception staging at `date` ...

( sqlplus -s /nolog <<-EOF

   whenever oserror  exit failure rollback
   whenever sqlerror exit failure rollback
   
   connect /@${MDMS_OPER}

   set serveroutput on size 1000000
   set define ~  echo on timing off linesize 160 pages 0 trimspool on heading off feedback off

   /* SQL Trace */
   alter session set sql_trace = ${sqlTrace};
   select 'Exception Mgmt Process from Staging' from dual;

   execute exception_batch.process_excptn_staging_table (p_entry_date => '$entryDate');

EOF
)
rc=$?
if [ ${rc} -ne 0 ]; then
   print Error running  Exception staging
   Fail "KEEP_MON"
fi

print
print Completed Exception staging at `date` ...
}

function getMeterHashes {
sqlplus -s /nolog <<EOF | read meterHashes
whenever oserror  exit failure rollback
whenever sqlerror exit failure rollback
connect /@${MDMS_OPER}
set echo off pages 0 lines 80 heading off verify off feedback off
select count(*) from all_tab_partitions where table_name = 'METERING_DEVICE' and table_owner = (select pkg_api_operator.get_owner from dual);
EOF

rc=$?
if [ ${rc} -ne 0 ]; then
   print Error getting the number of meter hashes
   Fail "KEEP_MON"
fi

export meterHashes
}

invokeWAVEprocess()
{
gatewayID=$1
gatewayAcronym="$2"

print
if [ -n "${groupName}" ]; then
	print Begin WAVE processing for gateway ${gatewayAcronym} with ID ${gatewayID}, group ${inGroupName} for ${entryDate} at `date` ...
else
        print Begin WAVE processing for gateway ${gatewayAcronym} with ID ${gatewayID} and  all the groups for ${entryDate} at `date` ...
fi
print

processesRunning=0
processThread=0

while [ ${processThread} -lt ${meterHashes} ]
do
   if [ ${processesRunning} -lt ${numProcesses} ]; then
      ((processThread=processThread+1))
      invokeWAVEthread $gatewayID ${processThread}  &
      ((processesRunning=processesRunning+1))
   else
      sleep 2
      processesRunning=`jobs | wc -l`
   fi
done
wait

#-----------------------------------------------------------------------
#  Determine if there are any thread monitor files that exist.  If there
#  are any, then at least 1 thread has failed, so this script will fail.
#-----------------------------------------------------------------------
threadFailures=`ls ${MON_THREAD_PATH}* 2>/dev/null | wc -l` 2>/dev/null
if [ ${threadFailures} -gt 0 ]; then
   print "${threadFailures} process thread failure(s) were detected, failing job !"
   ls ${MON_THREAD_PATH}*
   Fail "KEEP_MON"
else
   if [ -n "${groupName}" ]; then
   	print ... All WAVE processing threads for ${gatewayID}, group name ${groupName}  have completed successfully at `date`.
   else
	print ... All WAVE processing threads for ${gatewayID} and  all the groups  have completed successfully at `date`.
   fi
fi

print
if [ -n "${groupName}" ]; then
	print Completed WAVE processing for gateway ID ${gatewayID}, group name ${groupName} at `date` ...
else
	print Completed WAVE processing for gateway ID ${gatewayID} and  all the groups  at `date` ...
fi
}

function invokeWAVEthread {
gatewayID=$1
processThread=$2

#--------------------------------------------------------------
#  For each thread, touch a thread running monitor file.  If
#  its execution completes without error, remove it.  After
#  all threads complete, a test will be conducted to determine
#  if any of the threads encountered an error.
#--------------------------------------------------------------
touch ${MON_THREAD_PATH}${processThread}

if [ -n "${groupName}" ]; then
	print ... beginning WAVE process thread ${processThread} for gateway ID ${gatewayID}, group name  ${groupName} at `date`
else
	print ... beginning WAVE process thread ${processThread} for gateway ID ${gatewayID} and  all the groups  at `date`
fi

( sqlplus -s /nolog <<-EOF

   whenever oserror  exit failure rollback
   whenever sqlerror exit failure rollback
   
   connect /@${MDMS_OPER}

   set serveroutput on size 1000000
   set define ~  echo on timing on linesize 160 pages 0 trimspool on heading off feedback off

   /* SQL Trace */
   alter session set sql_trace = ${sqlTrace};
   select 'WAVE Processing for gateway Id $gatewayID  group name ${inGroupName} entryDate $entryDate  and thread $processThread ' from dual;


   /* Work around for bug 5079565 documented in PGE Oracle TAR 5386304.992 */
   alter session set skip_unusable_indexes = false;

   execute PKG_EST.WAVE_MAIN (1, 11, '$entryDate', 10000, ${processThread}, ${meterHashes}, $gatewayID,${groupId}, '$entryDate')

EOF
)
rc=$?
if [ ${rc} -ne 0 ]; then
   print Error running WAVE procedures thread ${processThread} for gateway ID ${gatewayID}
   Fail "KEEP_MON"
fi

rm -f ${MON_THREAD_PATH}${processThread}

if [ -n "${groupName}" ]; then
	print ... completed WAVE processing thread ${processThread} for gateway ${gatewayID}, group name ${groupName}  at `date`
else
	print ... completed WAVE processing thread ${processThread} for gateway ${gatewayID} and  all the groups  at `date`
fi
}

function refreshRateStructureMV {
print
print ... Begin refreshing the rate structure materialized view at `date`

( sqlplus -s /nolog <<-EOF

   whenever oserror  exit failure rollback
   whenever sqlerror exit failure rollback
   
   connect /@${MDMS_OPER}

   set serveroutput on size 1000000
   set define ~  echo on timing on linesize 160 pages 0 trimspool on heading off feedback off

   prompt Refresh materialized view V_RATE_STRUCTURE ...
   exec pkg_api_operator.refresh_mview ('V_RATE_STRUCTURE', 'c', 1);

EOF
)
rc=$?
if [ ${rc} -ne 0 ]; then
   print Error refreshing iWave UI materialized view
   Fail "KEEP_MON"
fi

print ... Completed refreshing the rate structure materialized view at `date`
}

#--------------------------------------------------------------------------------------------
# Main
#--------------------------------------------------------------------------------------------

export PGM_PATH=$0
export PGM_DIR=`dirname $PGM_PATH`
export PGM_NM=`basename $PGM_PATH`
export USAGE="$PGM_NM"

print
print -- "----------------------------------------------------------------------------------------------------------"
print $PGM_NM starting at `date` ...

initializeScript $*

. ${MDM_HOME}/bin/wacslib.ksh

getDefaultValues
numProcesses=$?
if [ ! -z "${inumProcesses}" ]; then
  numProcesses=${inumProcesses}
fi

#----------------------------------------------------------------------------------------------
# Retrieve the number of partitions from database
#----------------------------------------------------------------------------------------------
getNumberOfPartition
partition=$?
if [ "${partition}" = "0" ]; then
        print  "No Partitions not found!! Exiting"
        exit 1
else
        maxProcesses=$partition
fi

processInputParameters

# These variables are required.
Check_Env_Var MDM_MON_DIR             'Process Monitor Directory'

# Do process monitoring (to ensure that only one instance of program runs at once.
Check_Path $MDM_MON_DIR 'Process Monitor Directory' # Validate that the monitoring directory exists.
MON_FILE=$PGM_NM.running
MON_PATH=$MDM_MON_DIR/$MON_FILE
# Another version of the program running?  Terminate (only one instance at a time is allowed).  Don't delete the process monitoring file that's in use!
if [[ -f $MON_PATH ]]; then print "Another instance of $PGM_NM is running (Monitor File $MON_PATH exists)!"; Fail "KEEP_MON"; fi
touch $MON_PATH   # Flag that an instance of the program is running.

#----------------------------------
# Get the entry date for processing
#----------------------------------
if [ -n "${inEntryDate}" ]; then
   entryDate=${inEntryDate}
else
sqlplus -s /nolog <<EOF | read entryDate
connect /@${MDMS_OPER}
set echo off feedback off verify off pages 0 lines 80
select trunc(sysdate) from dual;
EOF
fi
rc=$?
if [ ${rc} -ne 0 ]; then
   print Error getting entry date
   Fail "KEEP_MON"
fi
print "Process entry date:  ${entryDate}"

#-----------------------------------------
#  Get the number of Meter hash partitions
#-----------------------------------------
getMeterHashes

#-----------------------------------------
# Invoke exception staging
#-----------------------------------------
invokeExceptionProcessing


#----------------------------------
#  Thread monitor file name pattern
#----------------------------------
MON_THREAD_PATH=${MON_PATH}.thread_

#---------------------------------------------
# If gateway ID passed, Process ONLY for the gatway passed.
# If gateway ID not passed, Process for all the gateways.
#---------------------------------------------

if [ -n "${gatewayId}" ]; then
    refreshRateStructureMV
    checkGatewayId ${gatewayId}
    invokeWAVEprocess ${gatewayId} "${gatewayAcronym}" 
else
   #---------------------------------------------------------------
   #  Get the gateways to be processed and invoke WAVE for each one
   #  If group name  passed, call getDGMCUMGatewaysToProcessWithGroupName
   #  if group name NOT  passed, call getDGMCUMGatewaysToProcess
   #---------------------------------------------------------------
   if [ -n "${groupName}" ]; then
	print groupId=${groupId}
	getDGMCUMGatewaysToProcessWithGroupName "${PGM_NM}" "${groupName}" "WAVE"
   else
   	getDGMCUMGatewaysToProcess "${PGM_NM}" "WAVE" 
   fi
   numGatewaysToProcess=${#gatewaysToProcessArray[*]} 
   if [ $numGatewaysToProcess -gt 0 ];then
   	# Refresh rate structure materialized view
	# No need to refresh if No gateways to process..
	refreshRateStructureMV
  	x=0 
        while [ $x -lt $numGatewaysToProcess ] 
 	do 
	    checkGatewayId ${gatewaysToProcessArray[x]} 
   	    invokeWAVEprocess ${gatewaysToProcessArray[x]} "${gatewayAcronym}" 
   	    ((x=x+1)) 
	done 
   else
        	print "No gateways match to process.."
   fi
fi


# Remove the process monitoring file.
Rm_Mon

print "$PGM_NM completed successfully at `date`."

exit 0
